%skeleton "lalr1.cc"
%require "3.4"

%defines 
%define api.parser.class {Syntax}
%define parse.error verbose
%define lr.default-reduction accepting

%locations

// codi que s'injecta al hpp
%code requires{
    class Driver;
    class Lexic;
    
    #include "simbols/Simbols.h"
}

// paràmetres del constructor del sintàctic
%parse-param { Lexic *myScanner }
%parse-param { Driver *driver }

// codi que s'injecta al cpp
%code{
    #include "simbols/Simbols.h"
    #include "Lexic.h"
    #include "Driver.h"
    
    #undef yylex
    #define yylex myScanner->getToken
}

%token-table

// tokens, quedaran definits a <filename>.tab.hpp
%token <std::string> ID
%token <std::string> STR_LITERAL
%token <int> INT_LITERAL
%token <char> CHAR_LITERAL

%token ENDFILE 0

// operadors aritmètics
%token OP_ADD
%token OP_MINUS
%token OP_TIMES
%token OP_DIV
%token OP_MOD

// operadors relacionals
%token OP_GT
%token OP_LT
%token OP_EQ
%token OP_NEQ
%token OP_GTE
%token OP_LTE

// símbols reservats
%token SQUOTE
%token DQUOTE
%token EQ
%token SEMICOLON
%token COLON
%token COMA
%token LEFTPARAN
%token RIGHTPARAN
%token LEFTBRACKET
%token RIGHTBRACKET
%token RIGHTCBRACKET
%token LEFTCBRACKET

// paraules reservades
%token PROC
%token FUNC
%token BBEGIN
%token BEND
%token DO
%token AND
%token OR
%token NOT
%token FOR
%token WHILE
%token IF
%token ELSE
%token CONST
%token BREAK
%token RETURN
%token SWITCH
%token CASE
%token DEFAULT

// Tipus dels símbols no terminals
// %type <Tipus> <no terminal>
%define api.value.type variant
%define parse.assert

%type <SimbolPrograma> program
%type <SimbolDeclList> declList
%type <SimbolDecl> decl
%type <SimbolVarDecl> varDecl
%type <SimbolVarInit> varInit 
%type <SimbolFuncDecl> funcDecl
%type <SimbolFuncCap> funcCap
%type <SimbolFuncContCap> funcContCap
%type <SimbolBloc> bloc
%type <SimbolProcDecl> procDecl
%type <SimbolProcCap> procCap
%type <SimbolProcContCap> procContCap
%type <SimbolArgType> argType
%type <SimbolTipus> Tipus;
%type <SimbolTipusArray> array;
%type <SimbolTipusArray> contArray;

%type <SimbolStatementList> statementList
%type <SimbolStatement> statement;
%type <SimbolWhileStatement> whileIteration
%type <SimbolForStatement> forIteration
%type <SimbolForInit> forInit
%type <SimbolForPostExpression> forPostExpression
%type <SimbolSwitchStatement> switchStatement
%type <SimbolContSwitch> contSwitch

%type <SimbolIfStatement> ifStatement
%type <SimbolElseIfStatement> elseIfStatement
%type <SimbolElseStatement> elseStatement

%type <SimbolExpressio> exprSimple
%type <SimbolReferencia> referencia
%type <SimbolRelExpr> relExpr
%type <SimbolArithmeticExpression> aritExpr
%type <SimbolAssignacio> expression

%type <SimbolSubProgramCall> subProgramCall
%type <SimbolSubProgramContCall> subProgramContCall
%type <SimbolLiteral> literal

%type <SimbolArrayInit> arrayInit
%type <SimbolArrayElementList> arrayElementList
%type <SimbolArrayInitList> arrayInitList
%type <SimbolArrayFinalList> arrayFinalList

%left OP_TIMES OP_DIV OP_MOD AND NOT
%left OP_ADD OP_MINUS OR
%left OP_EQ OP_GT OP_GTE OP_LT OP_LTE OP_NEQ
%left IF ELSE

%start program
%%

program : declList { $$.make(this->driver, $1); };

declList : declList decl { $$.make(this->driver, $2, $1); };
    | decl { $$.make(this->driver, $1); };

decl : varDecl SEMICOLON { $$.make(this->driver, $1); };
    | varDecl error decl { };
    | funcDecl { $$.make(this->driver, $1); };
    | procDecl { $$.make(this->driver, $1); };

varDecl : CONST Tipus ID varInit { $$.make(this->driver, $2, $3, $4, true); }
    | Tipus ID varInit { $$.make(this->driver, $1, $2, $3, false); }
    | varDecl COMA ID varInit { $$.make(this->driver, $1, $3, $4); };

varInit : EQ exprSimple{ $$.make(this->driver, $2); }
    | EQ arrayInit { $$.make(this->driver, $2); }
    | { $$.make(this->driver); };

arrayInit : ID LEFTCBRACKET arrayElementList RIGHTCBRACKET { $$.make(this->driver, $1, $3); }
arrayElementList : arrayFinalList { $$.make(this->driver, $1); }
    | arrayInitList { $$.make(this->driver, $1); }
    | { $$.make(this->driver); };

arrayInitList : arrayInitList COMA LEFTCBRACKET arrayElementList RIGHTCBRACKET { $$.make(this->driver, $1, $4); }
    | LEFTCBRACKET arrayElementList RIGHTCBRACKET { $$.make(this->driver, $2); };

arrayFinalList : exprSimple { $$.make(this->driver, $1); }
    | arrayFinalList COMA exprSimple { $$.make(this->driver, $1, $3); };

funcDecl : FUNC funcCap BBEGIN bloc BEND ID SEMICOLON {
    $$.make(this->driver, $2, $4, $6);
};

funcCap : funcContCap RIGHTPARAN COLON Tipus { $$.make(this->driver, $1, $4); }
    | ID LEFTPARAN RIGHTPARAN COLON Tipus { $$.make(this->driver, $1, $5); }


funcContCap : ID LEFTPARAN argType Tipus ID { $$.make(this->driver, $1, $3, $4, $5); }
    | funcContCap COMA argType Tipus ID { $$.make(this->driver, $1, $3, $4, $5); };

procDecl : PROC procCap BBEGIN bloc BEND ID SEMICOLON {
    $$.make(this->driver, $2, $4, $6);
};

procCap : procContCap RIGHTPARAN { $$.make(this->driver, $1); }
    | ID LEFTPARAN RIGHTPARAN { $$.make(this->driver, $1);  };

procContCap : ID LEFTPARAN argType Tipus ID { $$.make(this->driver, $1, $3, $4, $5); }
    | procContCap COMA argType Tipus ID { $$.make(this->driver, $1, $3, $4, $5); };

argType : CONST { $$.make(this->driver, true); }
    | { $$.make(this->driver, false); };

bloc : A statementList { 
    $$.make(this->driver, $2);
    this->driver->ts.surtirBloc();
};

A : { this->driver->ts.entrarBloc(); };

statementList : statement SEMICOLON statementList { $$.make(this->driver, $1, $3); }
    | statement error statementList { $$.make(this->driver, $1, $3); }
    | { $$.make(this->driver); };

statement : 
    varDecl { $$.make(this->driver, $1); }
    | expression { $$.make(this->driver, $1); }
    | subProgramCall { $$.make(this->driver, $1); }
    | forIteration { $$.make(this->driver, $1); }
    | whileIteration { $$.make(this->driver, $1); }
    | ifStatement { $$.make(this->driver, $1); }
    | switchStatement { $$.make(this->driver, $1); }
    | RETURN exprSimple { $$.make(this->driver, $2); }
    | BREAK { $$.make(this->driver, SimbolStatement::Tipus::BREAK); };
    
forIteration : FOR A LEFTPARAN forInit SEMICOLON exprSimple SEMICOLON forPostExpression RIGHTPARAN DO bloc BEND {
    $$.make(this->driver, $4, $6, $8, $11);
};

forInit : varDecl { $$.make(this->driver, $1); }
    | expression { $$.make(this->driver, $1); }
    | { $$.make(this->driver); };

forPostExpression : expression { $$.make(this->driver, $1); }
    | { $$.make(this->driver); };

whileIteration : WHILE LEFTPARAN exprSimple RIGHTPARAN DO bloc BEND {
    $$.make(this->driver, $3, $6);
};

ifStatement : IF exprSimple DO bloc elseIfStatement BEND {
    $$.make(this->driver, $2, $4, $5);
};

elseIfStatement :  ELSE IF exprSimple DO bloc elseIfStatement { $$.make(this->driver, $3, $5, $6); }
    | elseStatement { $$.make(this->driver, $1); } ;

elseStatement : ELSE DO bloc { $$.make(this->driver, $3); }
    | { $$.make(this->driver); };

switchStatement : SWITCH LEFTPARAN contSwitch BEND { $$.make(this->driver, $3); };

contSwitch : exprSimple RIGHTPARAN BBEGIN DEFAULT BBEGIN bloc BEND { $$.make(this->driver, $1, $6); }
    | exprSimple RIGHTPARAN BBEGIN CASE exprSimple BBEGIN bloc BEND { $$.make(this->driver, $1, $5, $7); }
    | contSwitch DEFAULT BBEGIN bloc BEND { $$.make(this->driver, $1, $4); }
    | contSwitch CASE exprSimple BBEGIN bloc BEND { $$.make(this->driver, $1, $3, $5); };


exprSimple : NOT exprSimple { $$.make(this->driver, $2, 0); }
    | LEFTPARAN exprSimple RIGHTPARAN { $$.make(this->driver, $2, 1); }
    | exprSimple AND exprSimple { $$.make(this->driver, $1, $3, 0); }
    | exprSimple OR exprSimple { $$.make(this->driver, $1, $3, 1); }
    | exprSimple IF exprSimple ELSE exprSimple { $$.make(this->driver, $1, $3, $5); }
    | referencia { $$.make(this->driver, $1); }
    | literal { $$.make(this->driver, $1); };
    | relExpr { $$.make(this->driver, $1); }
    | aritExpr { $$.make(this->driver, $1); };

aritExpr : OP_MINUS exprSimple { $$.make(this->driver, $2); }
    | exprSimple OP_ADD exprSimple { $$.make(this->driver, $1, $3, 0); }
    | exprSimple OP_MINUS exprSimple { $$.make(this->driver, $1, $3, 1); }
    | exprSimple OP_TIMES exprSimple { $$.make(this->driver, $1, $3, 2); }
    | exprSimple OP_DIV exprSimple { $$.make(this->driver, $1, $3, 3); };
    | exprSimple OP_MOD exprSimple { $$.make(this->driver, $1, $3, 4); };

relExpr : exprSimple OP_NEQ exprSimple { $$.make(this->driver, $1, $3, 0); }
    | exprSimple OP_EQ exprSimple { $$.make(this->driver, $1, $3, 1); }
    | exprSimple OP_GT exprSimple { $$.make(this->driver, $1, $3, 2); }
    | exprSimple OP_GTE exprSimple { $$.make(this->driver, $1, $3, 3); }
    | exprSimple OP_LT exprSimple { $$.make(this->driver, $1, $3, 4); }
    | exprSimple OP_LTE exprSimple { $$.make(this->driver, $1, $3, 5); };


referencia : ID { $$.make(this->driver, $1); }
    | array { $$.make(this->driver, $1); }
    | subProgramCall { $$.make(this->driver, $1); }
    ;

subProgramCall : ID LEFTPARAN RIGHTPARAN { $$.make(this->driver, $1); }
    | subProgramContCall RIGHTPARAN { $$.make(this->driver, $1); };

subProgramContCall : ID LEFTPARAN exprSimple { $$.make(this->driver, $1, $3); }
    | subProgramContCall COMA exprSimple { $$.make(this->driver, $1, $3); };

literal : STR_LITERAL { $$.make(this->driver, $1); }
    | INT_LITERAL { $$.make(this->driver, $1); }
    | CHAR_LITERAL { $$.make(this->driver, $1); };

Tipus : ID { $$.make(this->driver, $1); }
    | array { $$.make(this->driver, $1); }

array : contArray { $$.make(this->driver, $1); };

contArray : ID LEFTBRACKET exprSimple RIGHTBRACKET { $$.make(this->driver, $1, $3);}
    | contArray LEFTBRACKET exprSimple RIGHTBRACKET {
    $$.make(this->driver, $1, $3);
};

expression : referencia EQ exprSimple { $$.make(this->driver, $1, $3, 0); }
    | referencia EQ arrayInit { $$.make(this->driver, $1, $3); }
    | referencia OP_ADD EQ exprSimple { $$.make(this->driver, $1, $4, 1); }
    | referencia OP_DIV EQ exprSimple { $$.make(this->driver, $1, $4, 2); }
    | referencia OP_TIMES EQ exprSimple { $$.make(this->driver, $1, $4, 3); }
    | referencia OP_MINUS EQ exprSimple { $$.make(this->driver, $1, $4, 4); }
    | referencia OP_MINUS OP_MINUS { $$.make(this->driver, $1, 0); }
    | referencia OP_ADD OP_ADD { $$.make(this->driver, $1, 1); };
%%

// Codi de les funcions pròpies del sintàctic
void yy::Syntax::error(const location_type& loc, const std::string& msg){
    this->driver->error(msg, true);
}