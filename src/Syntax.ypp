%skeleton "lalr1.cc"
%require "3.4"

%defines 
%define api.parser.class {Syntax}


%locations

// codi que s'injecta al hpp
%code requires{
    class Driver;
    class Lexic;
    
    #include "simbols/Simbols.h"
}

// paràmetres del constructor del sintàctic
%parse-param { Lexic *myScanner }
%parse-param { Driver *driver }

// codi que s'injecta al cpp
%code{
    #include "simbols/Simbols.h"
    #include "Lexic.h"
    #include "Driver.h"
    
    #undef yylex
    #define yylex myScanner->getToken
}

%token-table

// tokens, quedaran definits a <filename>.tab.hpp
%token <std::string> ID
%token <std::string> STR_LITERAL
%token <int> INT_LITERAL
%token <char> CH_LITERAL

%token ENDFILE 0

// operadors aritmètics
%token OP_ADD
%token OP_MINUS
%token OP_TIMES
%token OP_DIV
%token OP_MOD

// operadors relacionals
%token OP_GT
%token OP_LT
%token OP_EQ
%token OP_NEQ
%token OP_GTE
%token OP_LTE

// símbols reservats
%token SQUOTE
%token DQUOTE
%token EQ
%token SEMICOLON
%token COLON
%token COMA
%token LEFTPARAN
%token RIGHTPARAN
%token LEFTBRACKET
%token RIGHTBRACKET

// paraules reservades
%token PROC
%token FUNC
%token BBEGIN
%token BEND
%token DO
%token AND
%token OR
%token NOT
%token FOR
%token WHILE
%token IF
%token ELSE
%token CONST
%token BREAK
%token RETURN
%token SWITCH
%token CASE
%token DEFAULT

// Tipus dels símbols no terminals
// %type <Tipus> <no terminal>
%define api.value.type variant
%define parse.assert

%type <SimbolPrograma> program
%type <SimbolDeclList> declList
%type <SimbolProcDecl> decl
%type <int> exprSimple
%type <SimbolProcDecl> varDecl
%type <SimbolProcDecl> funcDecl
%type <SimbolFuncCap> funcCap
%type <SimbolFuncContCap> funcContCap
%type <SimbolProcDecl> procDecl
//%type <Node_Declaracio> args;
//%type <Node_Declaracio> argList;
//%type <Node_Declaracio> argListCont;
%type <std::string> Tipus;
%type <SimbolTipusArray> array;
%type <SimbolTipusArray> contArray;

%left OP_ADD OP_MINUS OR
%left OP_TIMES OP_DIV AND NOT

%start program
%%

program : declList {
    $$.make($1);
};

declList : declList decl {
    if(!$1.getTeMain()){
        // fins ara no hem trobat un main
        $$.setTeMain($2.getEsMain());
    }else{
        // ja existeix un main
        $$.setTeMain($1.getTeMain());
    }
};
    | decl {
        $$.setTeMain($1.getEsMain());
};

decl : varDecl {
    // TODO
};
    | funcDecl {
    // TODO
};
    | procDecl {
    if($1.getEsMain()){
        $$.setEsMain(true);
    }
};

varDecl : const Tipus varDeclList varInit {
    // TODO
};

varDeclList : varDeclList COMA ID {
    // TODO
};
    | ID {
    // TODO
};

varInit : EQ exprSimple
    |
    ;
const : CONST
    {
        // TODO
    };
    |
    {
        // TODO
    };

funcDecl : FUNC funcCap BBEGIN bloc BEND ID SEMICOLON {
    // TODO: comprovar que bloc conté una instrucció (com a mínim return) i que és compatible
    // amb el tipus indicat per type
};

funcCap : funcContCap RIGHTPARAN COLON Tipus {}
    | ID LEFTPARAN RIGHTPARAN COLON Tipus {}

funcContCap : ID LEFTPARAN Tipus ID {
    $$.make(this->driver, $1, $3, $4);
};
    | funcContCap COMA Tipus ID {
    $$.make(this->driver, $1, $3, $4);
};

procDecl : PROC procCap BBEGIN bloc BEND ID SEMICOLON {
    //$$.make();
};

procCap : procContCap RIGHTPARAN {}
    | ID LEFTPARAN RIGHTPARAN {} ;

procContCap : ID LEFTPARAN Tipus ID {}
    | procContCap COMA Tipus ID {};



/*args : argList
    {
        std::cout << "Resolt arguments" << std::endl;
    };
    |
    {
        // TODO
        // Producció buida (no hi ha arguments)
    };

argList : type ID argListCont
    {
        try{
            Descripcio d = this->driver->ts.consulta($1);

            if(d.getTipus() != Tipus::TIPUS){
                std::cout << "Tipus no reconegut! ("<< $1 << ")" << std::endl;
            }
            
            std::cout << "Resolt argument " << $1 << " - " << $2 << std::endl;
        }catch(TaulaSimbols::NomNoExistent ex){
            std::cout << "Tipus no reconegut! ("<< $1 << ")" << std::endl;
        }
    };
argListCont : COMA argList 
    {

    };
    |
    {

    };
*/
bloc : statement SEMICOLON bloc
    {

    };
    |
    {

    };

statement : varDecl
    {

    };
    | iterationStatement
    {

    };
    | conditionStatement
    {

    };
    | returnStatement 
    {

    };
    | BREAK
    {

    };

iterationStatement : forIteration
    | whileIteration


forIteration : FOR LEFTPARAN forInit SEMICOLON exprSimple SEMICOLON forPostExpression RIGHTPARAN DO bloc BEND 
    {
        // TODO
    };

forInit : expression 
    {

    };
    |

forPostExpression : expression
    {

    };
    |

whileIteration : WHILE LEFTPARAN exprSimple RIGHTPARAN DO bloc BEND
    {
        // TODO
    };

conditionStatement : ifStatement 
    | switchStatement

ifStatement : IF exprSimple DO bloc elseIfStatement BEND
    {

    };

elseIfStatement : ELSE IF exprSimple DO bloc elseIfStatement
    {

    };
    | elseStatement {}

elseStatement : ELSE DO bloc
    {

    };

switchStatement : SWITCH LEFTPARAN exprSimple RIGHTPARAN BBEGIN caseBloc BEND
    {

    };

caseBloc : CASE literal DO bloc BEND caseBloc
    {

    };
    | DEFAULT DO bloc BEND
    {

    };
    |
    ;

exprSimple : NOT exprSimple {}
    | LEFTPARAN exprSimple RIGHTPARAN {}
    | exprSimple AND exprSimple {}
    | exprSimple OR exprSimple {}
    | aritExpr {}

aritExpr : OP_MINUS exprSimple {}
    | exprSimple OP_ADD exprSimple {}
    | exprSimple OP_MINUS exprSimple {}
    | exprSimple OP_TIMES exprSimple {}
    | exprSimple OP_DIV exprSimple {}
    | relExpr {}
    | operand

relExpr : operand relOp operand {};

relOp : OP_EQ {};
    | OP_NEQ {};
    | OP_GT {};
    | OP_GTE {};
    | OP_LT {};
    | OP_LTE {};

operand : mutable {}
    | immutable {}

mutable : ID
immutable : literal {}
    | funcCall {}

funcCall : ID LEFTPARAN largs RIGHTPARAN
    {

    };

largs : exprSimple contlargs
    | 
contlargs : COMA exprSimple contlargs
    {

    }
    |

returnStatement : RETURN exprSimple

literal : STR_LITERAL
    | INT_LITERAL

Tipus : ID {
    $$ = $1;
}
    | array {
    $$ = $1.toString();
    std::cout << "Nom array: " << $1.toString() << std::endl;
}

// Aquesta serà la darrera dimensió
array : contArray LEFTBRACKET INT_LITERAL RIGHTBRACKET {
    $$ = $1;
    $$.make(this->driver, $3);
    $$.make(this->driver);
};

contArray : ID {
    $$.make(this->driver, $1);
}
    | contArray LEFTBRACKET INT_LITERAL RIGHTBRACKET {
    $$ = $1;
    $$.make(this->driver, $3);
};

expression : mutable EQ exprSimple {}
    | mutable OP_ADD EQ exprSimple {}

%%

// Codi de les funcions pròpies del sintàctic
void yy::Syntax::error(const location_type& loc, const std::string& msg)
{
   std::cerr << "Error: " << msg << " at " << loc << "\n";
}