%skeleton "lalr1.cc"
%require "3.4"

%defines 
%define api.parser.class {Syntax}
%define parse.error verbose

%locations

// codi que s'injecta al hpp
%code requires{
    class Driver;
    class Lexic;
    
    #include "simbols/Simbols.h"
}

// paràmetres del constructor del sintàctic
%parse-param { Lexic *myScanner }
%parse-param { Driver *driver }

// codi que s'injecta al cpp
%code{
    #include "simbols/Simbols.h"
    #include "Lexic.h"
    #include "Driver.h"
    
    #undef yylex
    #define yylex myScanner->getToken
}

%token-table

// tokens, quedaran definits a <filename>.tab.hpp
%token <std::string> ID
%token <std::string> STR_LITERAL
%token <int> INT_LITERAL
%token <char> CHAR_LITERAL

%token ENDFILE 0

// operadors aritmètics
%token OP_ADD
%token OP_MINUS
%token OP_TIMES
%token OP_DIV
%token OP_MOD

// operadors relacionals
%token OP_GT
%token OP_LT
%token OP_EQ
%token OP_NEQ
%token OP_GTE
%token OP_LTE

// símbols reservats
%token SQUOTE
%token DQUOTE
%token EQ
%token SEMICOLON
%token COLON
%token COMA
%token LEFTPARAN
%token RIGHTPARAN
%token LEFTBRACKET
%token RIGHTBRACKET

// paraules reservades
%token PROC
%token FUNC
%token BBEGIN
%token BEND
%token DO
%token AND
%token OR
%token NOT
%token FOR
%token WHILE
%token IF
%token ELSE
%token CONST
%token BREAK
%token RETURN
%token SWITCH
%token CASE
%token DEFAULT

// Tipus dels símbols no terminals
// %type <Tipus> <no terminal>
%define api.value.type variant
%define parse.assert

%type <SimbolPrograma> program
%type <SimbolDeclList> declList
%type <SimbolDecl> decl
%type <SimbolProcDecl> varDecl
%type <SimbolFuncDecl> funcDecl
%type <SimbolFuncCap> funcCap
%type <SimbolFuncContCap> funcContCap
%type <SimbolBloc> bloc
%type <SimbolProcDecl> procDecl

%type <Simbol> const;

//%type <Node_Declaracio> args;
//%type <Node_Declaracio> argList;
//%type <Node_Declaracio> argListCont;
%type <std::string> Tipus;
%type <SimbolTipusArray> array;
%type <SimbolTipusArray> contArray;

%type <SimbolStatementList> statementList
%type <SimbolStatement> statement;
%type <SimbolWhileStatement> whileIteration
%type <SimbolIfStatement> ifStatement

%type <SimbolExpressio> exprSimple
%type <SimbolReferencia> referencia
%type <SimbolSubProgramCall> subProgramCall
%type <SimbolSubProgramContCall> subProgramContCall
%type <SimbolLiteral> literal

%left OP_ADD OP_MINUS OR
%left OP_TIMES OP_DIV AND NOT
%left OP_EQ OP_GT OP_GTE OP_LT OP_LTE OP_NEQ

%start program
%%

program : declList {
    $$.make(this->driver, $1);
};

declList : declList decl {
    $$.make(this->driver, $2, $1);
};
    | decl {
        $$.make(this->driver, $1);
};

decl : varDecl {
    // TODO
};
    | funcDecl {
    // TODO
};
    | procDecl {

};

varDecl : const Tipus ID varInit {};
    | varDecl, ID varInit {};

varInit : EQ exprSimple
    |
    ;

const : CONST { };
    | { $$.makeEmpty(); };

funcDecl : FUNC funcCap BBEGIN bloc BEND ID SEMICOLON {
    // TODO: comprovar que bloc conté una instrucció (com a mínim return) i que és compatible
    // amb el tipus indicat per type
    $$.make(this->driver, $2, $4, $6);
};

funcCap : funcContCap RIGHTPARAN COLON Tipus { $$.make(this->driver, $1, $4); }
    | ID LEFTPARAN RIGHTPARAN COLON Tipus { $$.make(this->driver, $1, $5); }

funcContCap : ID LEFTPARAN Tipus ID {
    $$.make(this->driver, $1, $3, $4);
};
    | funcContCap COMA Tipus ID {
    $$.make(this->driver, $1, $3, $4);
};

procDecl : PROC procCap BBEGIN bloc BEND ID SEMICOLON {
    //$$.make();
};

procCap : procContCap RIGHTPARAN {}
    | ID LEFTPARAN RIGHTPARAN {} ;

procContCap : ID LEFTPARAN Tipus ID {}
    | procContCap COMA Tipus ID {};



/*args : argList
    {
        std::cout << "Resolt arguments" << std::endl;
    };
    |
    {
        // TODO
        // Producció buida (no hi ha arguments)
    };

argList : type ID argListCont
    {
        try{
            Descripcio d = this->driver->ts.consulta($1);

            if(d.getTipus() != Tipus::TIPUS){
                std::cout << "Tipus no reconegut! ("<< $1 << ")" << std::endl;
            }
            
            std::cout << "Resolt argument " << $1 << " - " << $2 << std::endl;
        }catch(TaulaSimbols::NomNoExistent ex){
            std::cout << "Tipus no reconegut! ("<< $1 << ")" << std::endl;
        }
    };
argListCont : COMA argList 
    {

    };
    |
    {

    };
*/
/*bloc : statement SEMICOLON bloc
    {

    };
    |
    {

    };*/

bloc : A statementList { 
    $$.make(this->driver, $2);
    // TODO: surt bloc
};

A : { this->driver->ts.entrarBloc(); };
statementList :  statement SEMICOLON statementList { $$.make(this->driver, $1, $3); }
    | { $$.makeEmpty(); };

statement : 
    varDecl {}
    | forIteration {}
    | whileIteration { $$.make(this->driver, $1); }
    | ifStatement { $$.make(this->driver, $1); }
    | switchStatement {}
    | RETURN exprSimple { $$.make(this->driver, $2); }
    | BREAK { $$.make(this->driver, SimbolStatement::Tipus::BREAK); };

forIteration : FOR LEFTPARAN forInit SEMICOLON exprSimple SEMICOLON forPostExpression RIGHTPARAN DO bloc BEND {

};

forInit : expression 
    {

    };
    |

forPostExpression : expression
    {

    };
    |

whileIteration : WHILE LEFTPARAN exprSimple RIGHTPARAN DO bloc BEND {
    $$.make(this->driver, $3, $6);
};


ifStatement : IF exprSimple DO bloc elseIfStatement BEND {
    $$.make(this->driver, $2, $4);
};

elseIfStatement : ELSE IF exprSimple DO bloc elseIfStatement {}
    | elseStatement {} ;

elseStatement : ELSE DO bloc {}
    | {};

switchStatement : SWITCH LEFTPARAN exprSimple RIGHTPARAN BBEGIN caseBloc BEND
    {

    };

caseBloc : CASE literal DO bloc BEND caseBloc
    {

    };
    | DEFAULT DO bloc BEND
    {

    };
    |
    ;


exprSimple : NOT exprSimple {}
    | LEFTPARAN exprSimple RIGHTPARAN {}
    | exprSimple AND exprSimple {}
    | exprSimple OR exprSimple {}
    | aritExpr {}
    | referencia {}
    | literal { $$.make(this->driver, $1); };

aritExpr : OP_MINUS exprSimple {}
    | exprSimple OP_ADD exprSimple {}
    | exprSimple OP_MINUS exprSimple {}
    | exprSimple OP_TIMES exprSimple {}
    | exprSimple OP_DIV exprSimple {}
    | relExpr {};

relExpr : exprSimple OP_NEQ exprSimple {}
    | exprSimple OP_EQ exprSimple {}
    | exprSimple OP_GT exprSimple {}
    | exprSimple OP_GTE exprSimple {}
    | exprSimple OP_LT exprSimple {}
    | exprSimple OP_LTE exprSimple {};


referencia : ID { $$.make(this->driver, $1); }
    | subProgramCall {}
    | referenciaArray {};

referenciaArray : referenciaContArray LEFTBRACKET exprSimple RIGHTBRACKET {};
referenciaContArray : referenciaContArray LEFTBRACKET exprSimple RIGHTBRACKET {}
    | ID {};

subProgramCall : ID LEFTPARAN RIGHTPARAN { $$.make(this->driver, $1); }
    | subProgramContCall RIGHTPARAN { $$.make(this->driver, $1); };

subProgramContCall : ID LEFTPARAN exprSimple { $$.make(this->driver, $1, $3); }
    | subProgramContCall COMA exprSimple { $$.make(this->driver, $1, $3); };

mutable : ID {};

literal : STR_LITERAL { $$.make(this->driver, $1); }
    | INT_LITERAL { $$.make(this->driver, $1); }
    | CHAR_LITERAL { $$.make(this->driver, $1); };

Tipus : ID {
    $$ = $1;
}
    | array {
    $$ = $1.toString();
    std::cout << "Nom array: " << $1.toString() << std::endl;
};

// Aquesta serà la darrera dimensió
array : contArray LEFTBRACKET INT_LITERAL RIGHTBRACKET {
    $$.make(this->driver, $1, $3);
    $$.make(this->driver);
};

contArray : ID {
    $$.make(this->driver, $1);
}
    | contArray LEFTBRACKET INT_LITERAL RIGHTBRACKET {
    $$.make(this->driver, $1, $3);
};

expression : mutable EQ exprSimple {}
    | mutable OP_ADD EQ exprSimple {};
%%

// Codi de les funcions pròpies del sintàctic
void yy::Syntax::error(const location_type& loc, const std::string& msg)
{
   std::cerr << "Error: " << msg << " at " << loc << "\n";
}