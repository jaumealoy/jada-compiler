%skeleton "lalr1.cc"
%require "3.4"

%defines 
%define api.parser.class {Syntax}


%locations

// codi que s'injecta al hpp
%code requires{
    #include "tree/Node.h"
    class Driver;
    class Lexic;
}

// paràmetres del constructor del sintàctic
%parse-param { Lexic *myScanner }
%parse-param { Driver *driver }

// codi que s'injecta al cpp
%code{
    #include "Lexic.h"
    #include "tree/Node.h"

    #include "Driver.h"
    #undef yylex
    #define yylex myScanner->getToken
}

%token-table

// tokens, quedaran definits a <filename>.tab.hpp
%token <std::string> ID
%token <std::string> STR_LITERAL
%token <int> INT_LITERAL

%token ENDFILE 0

// operadors aritmètics
%token OP_ADD
%token OP_MINUS
%token OP_TIMES
%token OP_DIV
%token OP_MOD

// operadors relacionals
%token OP_GT
%token OP_LT
%token OP_EQ
%token OP_NEQ
%token OP_GTE
%token OP_LTE

// símbols reservats
%token SQUOTE
%token DQUOTE
%token EQ
%token SEMICOLON
%token COLON
%token COMA
%token LEFTPARAN
%token RIGHTPARAN

// paraules reservades
%token PROC
%token FUNC
%token BBEGIN
%token BEND
%token DO
%token AND
%token OR
%token NOT
%token FOR
%token WHILE
%token IF
%token ELSE
%token CONST
%token BREAK
%token RETURN
%token SWITCH
%token CASE
%token DEFAULT

// Tipus dels símbols no terminals
// %type <Tipus> <no terminal>
%define api.value.type variant
%define parse.assert

%type <Node_Program> program
%type <Node_DeclarationList> declList
%type <Node_Declaracio> decl
%type <Node_Declaracio> exprSimple
%type <Node_Declaracio> varDecl
%type <Node_Declaracio> funcDecl
%type <Node_Declaracio> procDecl
%type <Node_Declaracio> args;
%type <Node_Declaracio> argList;
%type <Node_Declaracio> argListCont;

%start program
%%

program : declList {
    //$$ = new Node_Program();
    //$$->setDeclaracions($1);
    //this->driver->setRoot($$);
    cout << "Programa trobat" << endl; 
};

declList : declList decl 
    {
        //$$ = new Node_DeclarationList();
        //$$->setDeclaracions($1);
        //$$->setDeclaracio($2);
    };
    | decl 
    {
        //$$ = new Node_DeclarationList();
        //$$->setDeclaracio($1);
    };

decl : varDecl 
    {
        // TODO
    };
    | funcDecl
    {
        // TODO
    };
    | procDecl {
        // TODO
    };

varDecl : const type varDeclList varInit 
    {
        // TODO
    };

varDeclList : varDeclList COMA ID
    {
        // TODO
    };
    | ID
    {
        // TODO
    };

varInit : EQ exprSimple
    |
    ;
const : CONST
    {
        // TODO
    };
    |
    {
        // TODO
    };

funcDecl : FUNC ID LEFTPARAN args RIGHTPARAN COLON type BBEGIN bloc BEND ID SEMICOLON
    {
        // TODO
    };

procDecl : PROC ID LEFTPARAN args RIGHTPARAN BBEGIN bloc BEND ID SEMICOLON
    {
        // TODO
    };

args : argList
    {

    };
    |
    {
        // TODO
        // Producció buida (no hi ha arguments)
    };

argList : type ID argListCont
    {

    };
argListCont : COMA argList 
    {

    };
    |
    {

    };

bloc : statement SEMICOLON bloc
    {

    };
    |
    {

    };

statement : varDecl
    {

    };
    | iterationStatement
    {

    };
    | conditionStatement
    {

    };
    | returnStatement 
    {

    };
    | BREAK
    {

    };

iterationStatement : forIteration
    | whileIteration


forIteration : FOR LEFTPARAN forInit SEMICOLON exprSimple SEMICOLON forPostExpression RIGHTPARAN DO bloc BEND 
    {
        // TODO
    };

forInit : expression 
    {

    };
    |

forPostExpression : expression
    {

    };
    |

whileIteration : WHILE LEFTPARAN exprSimple RIGHTPARAN DO bloc BEND
    {
        // TODO
    };

conditionStatement : ifStatement 
    | switchStatement

ifStatement : IF exprSimple DO bloc elseIfStatement BEND
    {

    };

elseIfStatement : ELSE IF exprSimple DO bloc elseIfStatement
    {

    };
    | elseStatement {}

elseStatement : ELSE DO bloc
    {

    };

switchStatement : SWITCH LEFTPARAN exprSimple RIGHTPARAN BBEGIN caseBloc BEND
    {

    };

caseBloc : CASE literal DO bloc BEND caseBloc
    {

    };
    | DEFAULT DO bloc BEND
    {

    };
    |
    ;

exprSimple : NOT exprSimple {}
    | orExpression {}

orExpression : orExpression OR andExpression {};
    | andExpression {};

andExpression : andExpression AND unaryExpression {};
    | unaryExpression {};

unaryExpression :  relExpr
    | aritExpr {};


aritExpr : OP_MINUS aritExpr {}
    | sumExpression

sumExpression : sumExpression OP_ADD factorExpr {};
    | sumExpression OP_MINUS factorExpr {};
    | factorExpr {};

factorExpr : factorExpr OP_TIMES simpleTerm {};
    | factorExpr OP_DIV simpleTerm {};
    | simpleTerm {};

simpleTerm : LEFTPARAN exprSimple RIGHTPARAN {};
    | operand {};

relExpr : operand relOp operand {};

relOp : OP_EQ {};
    | OP_NEQ {};
    | OP_GT {};
    | OP_GTE {};
    | OP_LT {};
    | OP_LTE {};

operand : mutable {}
    | immutable {}

mutable : ID
immutable : literal {}
    | funcCall {}

funcCall : ID LEFTPARAN largs RIGHTPARAN
    {

    };

largs : exprSimple contlargs
    | 
contlargs : COMA exprSimple contlargs
    {

    }
    |

returnStatement : RETURN exprSimple

literal : STR_LITERAL
    | INT_LITERAL
type : ID

expression : mutable EQ exprSimple {}
    | mutable OP_ADD EQ exprSimple {}

%%

// Codi de les funcions pròpies del sintàctic
void yy::Syntax::error(const location_type& loc, const std::string& msg)
{
   std::cerr << "Error: " << msg << " at " << loc << "\n";
}